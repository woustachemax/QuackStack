import fs from "fs";
import path from "path";
import os from "os";
import { search } from "../commands/search.js";

export async function generateCodebaseDoc(projectName: string) {
  console.log("üîç Analyzing your codebase...\n");
  
  const queries = [
    "What is the overall architecture and design patterns used?",
    "What are the main entry points and how does the application start?",
    "What are the core features and functionalities?",
    "What external APIs, services, and dependencies are used?",
    "What is the database schema and data flow?",
    "What are the key algorithms or business logic implementations?",
  ];

  let doc = `# ${projectName} - Codebase Documentation\n\n`;
  doc += `**Auto-generated by QuackStack** | Last updated: ${new Date().toLocaleString()}\n\n`;
  doc += `This document provides a high-level overview of the codebase architecture, key components, and design decisions.\n\n`;
  doc += `---\n\n`;

  doc += `## üìã Table of Contents\n\n`;
  queries.forEach((q, i) => {
    const anchor = q.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    doc += `${i + 1}. [${q}](#${anchor})\n`;
  });
  doc += `\n---\n\n`;

  for (const query of queries) {
    try {
      const { answer, sources } = await search(query, projectName);
      doc += `## ${query}\n\n`;
      doc += `${answer}\n\n`;
      
      if (sources.length > 0) {
        doc += `### üìÅ Key Files\n\n`;
        sources.slice(0, 5).forEach(s => {
          doc += `- \`${s.filePath}\``;
          if (s.functionName) {
            doc += ` - ${s.functionName}`;
          }
          doc += `\n`;
        });
        doc += `\n`;
      }
      doc += `---\n\n`;
    } catch (e) {
      console.error(`Error analyzing: ${query}`);
    }
  }

  doc += `## üìÇ Project Structure\n\n`;
  doc += '```\n';
  doc += await getProjectStructure(process.cwd());
  doc += '```\n\n';
  doc += `---\n\n`;

  doc += `## üöÄ Getting Started\n\n`;
  doc += `### Prerequisites\n`;
  doc += `Check \`package.json\` for dependencies and Node.js version requirements.\n\n`;
  doc += `### Installation\n`;
  doc += '```bash\n';
  doc += 'npm install\n';
  doc += '```\n\n';
  doc += `### Running the Project\n`;
  doc += `Refer to \`package.json\` scripts section for available commands.\n\n`;
  doc += `---\n\n`;

  
  doc += `## üîÑ Updating This Document\n\n`;
  doc += `This documentation is auto-generated. To regenerate:\n\n`;
  doc += '```bash\n';
  doc += 'quack --docs\n';
  doc += '```\n\n';
  doc += `For interactive codebase Q&A, run \`quack\` in your terminal.\n`;

  const docPath = path.join(process.cwd(), "CODEBASE.md");
  fs.writeFileSync(docPath, doc, "utf-8");
  console.log(`‚úÖ Generated ${docPath}`);
}


export async function generateContextFiles(projectName: string) {
  console.log("üîç Generating context for AI coding assistants...\n");
  
  const queries = [
    "What is the overall architecture of this project?",
    "What are the main entry points and how does the code flow?",
    "What are the key functions and classes?",
    "What external dependencies and APIs are used?",
    "What is the project structure and organization?",
  ];

  let baseContext = `# ${projectName} - Codebase Context\n\n`;
  baseContext += `Generated: ${new Date().toISOString()}\n\n`;
  baseContext += "This file is auto-generated by QuackStack to provide AI assistants with codebase context.\n\n";
  baseContext += "---\n\n";

  for (const query of queries) {
    try {
      const { answer, sources } = await search(query, projectName);
      baseContext += `## ${query}\n\n${answer}\n\n`;
      
      if (sources.length > 0) {
        baseContext += "**Key files:**\n";
        sources.slice(0, 3).forEach(s => {
          baseContext += `- ${s.filePath}\n`;
        });
        baseContext += "\n";
      }
    } catch (e) {
      console.error(`Error generating context for: ${query}`);
    }
  }

  baseContext += "---\n\n## Project Structure\n\n";
  baseContext += await getProjectStructure(process.cwd());

  await generateCursorRules(baseContext);
  await generateWindsurfContext(baseContext);
  await generateClineContext(baseContext);
  await generateContinueContext(baseContext);
  await generateAiderContext(baseContext);
  
  console.log("\n‚úÖ Context files generated for:");
  console.log("  - Cursor (.cursorrules)");
  console.log("  - Windsurf (.windsurfrules)");
  console.log("  - Cline (.clinerules)");
  console.log("  - Continue (.continuerules)");
  console.log("  - Aider (.aider.conf.yml)");
  console.log("\nüí° Your AI coding assistant will now have full codebase context!");
}


async function generateCursorRules(context: string) {
  const cursorPath = path.join(process.cwd(), ".cursorrules");
  fs.writeFileSync(cursorPath, context, "utf-8");
}

async function generateWindsurfContext(context: string) {
  const windsurfPath = path.join(process.cwd(), ".windsurfrules");
  fs.writeFileSync(windsurfPath, context, "utf-8");
}


async function generateClineContext(context: string) {
  const clinePath = path.join(process.cwd(), ".clinerules");
  fs.writeFileSync(clinePath, context, "utf-8");
}


async function generateContinueContext(context: string) {
  const continueDir = path.join(process.cwd(), ".continue");
  if (!fs.existsSync(continueDir)) {
    fs.mkdirSync(continueDir, { recursive: true });
  }
  const continuePath = path.join(continueDir, "context.md");
  fs.writeFileSync(continuePath, context, "utf-8");
}


async function generateAiderContext(context: string) {
  const aiderPath = path.join(process.cwd(), ".aider.conf.yml");
  const aiderConfig = `# Aider configuration with QuackStack context
# Project: ${path.basename(process.cwd())}

# Context file
read:
  - .aider.context.md

# Model settings
model: gpt-4o-mini
edit-format: whole
`;
  fs.writeFileSync(aiderPath, aiderConfig, "utf-8");
  fs.writeFileSync(path.join(process.cwd(), ".aider.context.md"), context, "utf-8");
}


export async function updateGlobalContext(projectName: string) {
  const quackDir = path.join(os.homedir(), ".quackstack");
  
  if (!fs.existsSync(quackDir)) {
    fs.mkdirSync(quackDir, { recursive: true });
  }

  const contextPath = path.join(quackDir, "contexts.json");
  
  let contexts: Record<string, any> = {};
  if (fs.existsSync(contextPath)) {
    contexts = JSON.parse(fs.readFileSync(contextPath, "utf-8"));
  }

  const { answer, sources } = await search(
    "Give a brief overview of what this project does and its main components",
    projectName
  );

  contexts[projectName] = {
    path: process.cwd(),
    overview: answer,
    topFiles: sources.slice(0, 5).map(s => s.filePath),
    lastUpdated: new Date().toISOString(),
  };

  fs.writeFileSync(contextPath, JSON.stringify(contexts, null, 2), "utf-8");
}


export function watchAndUpdateContext(projectName: string) {
  let timeout: NodeJS.Timeout;
  
  fs.watch(process.cwd(), { recursive: true }, (eventType, filename) => {
    if (!filename || filename.includes("node_modules") || filename.includes(".git")) {
      return;
    }

    clearTimeout(timeout);
    timeout = setTimeout(async () => {
      console.log("üìù Detected changes, updating context...");
      await generateContextFiles(projectName);
    }, 5000);
  });

  console.log("üëÄ Watching for file changes...");
}


async function getProjectStructure(dir: string, prefix = "", maxDepth = 3, currentDepth = 0): Promise<string> {
  if (currentDepth >= maxDepth) return "";
  
  let structure = "";
  const ignoreDirs = ["node_modules", ".git", "dist", "build", ".next"];
  
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true })
      .filter(e => !ignoreDirs.includes(e.name))
      .slice(0, 20);

    entries.forEach((entry, index) => {
      const isLast = index === entries.length - 1;
      const connector = isLast ? "‚îî‚îÄ‚îÄ " : "‚îú‚îÄ‚îÄ ";
      structure += `${prefix}${connector}${entry.name}\n`;
      
      if (entry.isDirectory() && currentDepth < maxDepth - 1) {
        const newPrefix = prefix + (isLast ? "    " : "‚îÇ   ");
        structure += getProjectStructure(
          path.join(dir, entry.name), 
          newPrefix, 
          maxDepth, 
          currentDepth + 1
        );
      }
    });
  } catch (e) {
  }
  
  return structure;
}