import fs from "fs";
import path from "path";
import os from "os";
import { search } from "../commands/search.js";


export async function generateCursorContext(projectName: string) {
  const cursorRulesPath = path.join(process.cwd(), ".cursorrules");
  
  const queries = [
    "What is the overall architecture of this project?",
    "What are the main entry points and how does the code flow?",
    "What are the key functions and classes?",
    "What external dependencies and APIs are used?",
  ];

  let context = "# QuackStack Codebase Context\n\n";
  context += "This file is auto-generated by QuackStack to provide AI assistants with codebase context.\n\n";
  context += "---\n\n";

  for (const query of queries) {
    try {
      const { answer, sources } = await search(query, projectName);
      context += `## ${query}\n\n${answer}\n\n`;
      
      if (sources.length > 0) {
        context += "**Key files:**\n";
        sources.slice(0, 3).forEach(s => {
          context += `- ${s.filePath}\n`;
        });
        context += "\n";
      }
    } catch (e) {
      console.error(`Error generating context for: ${query}`);
    }
  }

  context += "---\n\n## Project Structure\n\n";
  context += await getProjectStructure(process.cwd());

  fs.writeFileSync(cursorRulesPath, context, "utf-8");
  console.log(`‚úÖ Generated .cursorrules at ${cursorRulesPath}`);
  
  return cursorRulesPath;
}


export async function updateCursorGlobalContext(projectName: string) {
  const cursorDir = path.join(os.homedir(), ".cursor");
  
  if (!fs.existsSync(cursorDir)) {
    fs.mkdirSync(cursorDir, { recursive: true });
  }

  const globalContextPath = path.join(cursorDir, "quackstack-contexts.json");
  
  let contexts: Record<string, any> = {};
  if (fs.existsSync(globalContextPath)) {
    contexts = JSON.parse(fs.readFileSync(globalContextPath, "utf-8"));
  }

  const { answer, sources } = await search(
    "Give a brief overview of what this project does and its main components",
    projectName
  );

  contexts[projectName] = {
    path: process.cwd(),
    overview: answer,
    topFiles: sources.slice(0, 5).map(s => s.filePath),
    lastUpdated: new Date().toISOString(),
  };

  fs.writeFileSync(globalContextPath, JSON.stringify(contexts, null, 2), "utf-8");
  console.log(`‚úÖ Updated global Cursor context`);
}


async function getProjectStructure(dir: string, prefix = "", maxDepth = 3, currentDepth = 0): Promise<string> {
  if (currentDepth >= maxDepth) return "";
  
  let structure = "";
  const ignoreDirs = ["node_modules", ".git", "dist", "build", ".next"];
  
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true })
      .filter(e => !ignoreDirs.includes(e.name))
      .slice(0, 20); 

    entries.forEach((entry, index) => {
      const isLast = index === entries.length - 1;
      const connector = isLast ? "‚îî‚îÄ‚îÄ " : "‚îú‚îÄ‚îÄ ";
      structure += `${prefix}${connector}${entry.name}\n`;
      
      if (entry.isDirectory() && currentDepth < maxDepth - 1) {
        const newPrefix = prefix + (isLast ? "    " : "‚îÇ   ");
        structure += getProjectStructure(
          path.join(dir, entry.name), 
          newPrefix, 
          maxDepth, 
          currentDepth + 1
        );
      }
    });
  } catch (e) {
  }
  
  return structure;
}

export function watchAndUpdateCursor(projectName: string) {
  let timeout: NodeJS.Timeout;
  
  fs.watch(process.cwd(), { recursive: true }, (eventType, filename) => {
    if (!filename || filename.includes("node_modules") || filename.includes(".git")) {
      return;
    }

    clearTimeout(timeout);
    timeout = setTimeout(async () => {
      console.log("üìù Detected changes, updating Cursor context...");
      await generateCursorContext(projectName);
    }, 5000);
  });

  console.log("üëÄ Watching for file changes...");
}