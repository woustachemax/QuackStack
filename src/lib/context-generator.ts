import fs from "fs";
import path from "path";
import os from "os";
import { search, getRecentActivity } from "../commands/search.js";
import { client, getProjectAuthors } from "../lib/database.js";
import { gitHistory } from "../lib/git-history.js";

export async function generateCodebaseDoc(projectName: string) {
  console.log("Analyzing your codebase...\n");
  
  const queries = [
    "What is the overall architecture and design patterns used?",
    "What are the main entry points and how does the application start?",
    "What are the core features and functionalities?",
    "What external APIs, services, and dependencies are used?",
    "What is the database schema and data flow?",
    "What are the key algorithms or business logic implementations?",
  ];

  let doc = `# ${projectName} - Codebase Documentation\n\n`;
  doc += `**Auto-generated by QuackStack** | Last updated: ${new Date().toLocaleString()}\n\n`;
  doc += `This document provides a high-level overview of the codebase architecture, key components, and design decisions.\n\n`;
  
  if (gitHistory.isRepository()) {
    doc += `## Repository Information\n\n`;
    const currentBranch = gitHistory.getCurrentBranch();
    if (currentBranch) {
      doc += `**Current Branch:** ${currentBranch}\n\n`;
    }
    
    const recentCommits = gitHistory.getRecentCommits(10);
    if (recentCommits.length > 0) {
      doc += `**Recent Activity:**\n`;
      recentCommits.slice(0, 5).forEach(commit => {
        const date = new Date(commit.date).toLocaleDateString();
        doc += `- ${date} - ${commit.author}: ${commit.message.substring(0, 60)}${commit.message.length > 60 ? '...' : ''}\n`;
      });
      doc += `\n`;
    }
    
    doc += `---\n\n`;
  }
  
  doc += `## Table of Contents\n\n`;
  queries.forEach((q, i) => {
    const anchor = q.toLowerCase().replace(/[^a-z0-9]+/g, '-');
    doc += `${i + 1}. [${q}](#${anchor})\n`;
  });
  doc += `\n---\n\n`;

  for (const query of queries) {
    try {
      const { answer, sources } = await search(query, projectName);
      doc += `## ${query}\n\n`;
      doc += `${answer}\n\n`;
      
      if (sources.length > 0) {
        doc += `### Key Files\n\n`;
        sources.slice(0, 5).forEach(s => {
          doc += `- \`${s.filePath}\``;
          if (s.functionName) {
            doc += ` - ${s.functionName}`;
          }
          if (s.primaryAuthor) {
            doc += ` (maintained by ${s.primaryAuthor})`;
          }
          doc += `\n`;
        });
        doc += `\n`;
      }
      doc += `---\n\n`;
    } catch (e) {
      console.error(`Error analyzing: ${query}`);
    }
  }

  if (gitHistory.isRepository()) {
    doc += `## Contributors\n\n`;
    const authors = await getProjectAuthors(projectName);
    if (authors.length > 0) {
      doc += `This project has ${authors.length} contributor${authors.length > 1 ? 's' : ''}:\n\n`;
      authors.slice(0, 10).forEach((author, i) => {
        doc += `${i + 1}. **${author.author}** (${author.email})\n`;
        doc += `   - ${author.totalCommits} commits\n`;
        doc += `   - +${author.linesAdded} / -${author.linesRemoved} lines\n`;
        if (author.recentActivity) {
          const daysAgo = Math.floor((Date.now() - author.recentActivity.getTime()) / (1000 * 60 * 60 * 24));
          doc += `   - Last active ${daysAgo} days ago\n`;
        }
        if (author.filesOwned.length > 0) {
          doc += `   - Primary owner of ${author.filesOwned.length} files\n`;
        }
        doc += `\n`;
      });
      doc += `---\n\n`;
    }
  }

  doc += `## Project Structure\n\n`;
  doc += '```\n';
  doc += await getProjectStructure(process.cwd());
  doc += '```\n\n';
  doc += `---\n\n`;

  doc += `## üöÄ Getting Started\n\n`;
  doc += `### Prerequisites\n`;
  doc += `Check \`package.json\` for dependencies and Node.js version requirements.\n\n`;
  doc += `### Installation\n`;
  doc += '```bash\n';
  doc += 'npm install\n';
  doc += '```\n\n';
  doc += `### Running the Project\n`;
  doc += `Refer to \`package.json\` scripts section for available commands.\n\n`;
  doc += `---\n\n`;

  doc += `## Updating This Document\n\n`;
  doc += `This documentation is auto-generated. To regenerate:\n\n`;
  doc += '```bash\n';
  doc += 'quack --docs\n';
  doc += '```\n\n';
  doc += `For interactive codebase Q&A, run \`quack\` in your terminal.\n`;

  const docPath = path.join(process.cwd(), "CODEBASE.md");
  fs.writeFileSync(docPath, doc, "utf-8");
  console.log(`‚úÖ Generated ${docPath}`);
}

export async function generateContextFiles(projectName: string) {
  console.log("üîç Generating context for AI coding assistants...\n");
  
  const queries = [
    "What is the overall architecture of this project?",
    "What are the main entry points and how does the code flow?",
    "What are the key functions and classes?",
    "What external dependencies and APIs are used?",
    "What is the project structure and organization?",
  ];

  let baseContext = `# ${projectName} - Codebase Context\n\n`;
  baseContext += `Generated: ${new Date().toISOString()}\n\n`;
  baseContext += "This file is auto-generated by QuackStack to provide AI assistants with codebase context.\n\n";
  
  if (gitHistory.isRepository()) {
    baseContext += `## Git Repository Info\n\n`;
    const branch = gitHistory.getCurrentBranch();
    if (branch) {
      baseContext += `**Branch:** ${branch}\n\n`;
    }
    
    const recentActivity = await getRecentActivity(projectName, 7);
    if (recentActivity.length > 0) {
      baseContext += `**Recent Changes (Last 7 days):**\n\n`;
      recentActivity.slice(0, 5).forEach(item => {
        const daysAgo = Math.floor((Date.now() - item.lastCommitDate.getTime()) / (1000 * 60 * 60 * 24));
        baseContext += `- ${item.filePath}\n`;
        baseContext += `  - Modified by ${item.lastCommitAuthor} ${daysAgo} days ago\n`;
        if (item.lastCommitMessage) {
          baseContext += `  - "${item.lastCommitMessage.substring(0, 60)}${item.lastCommitMessage.length > 60 ? '...' : ''}"\n`;
        }
      });
      baseContext += `\n`;
    }
    
    const authors = await getProjectAuthors(projectName);
    if (authors.length > 0) {
      baseContext += `**Top Contributors:**\n\n`;
      authors.slice(0, 5).forEach(author => {
        baseContext += `- ${author.author} (${author.totalCommits} commits, owns ${author.filesOwned.length} files)\n`;
      });
      baseContext += `\n`;
    }
  }
  
  baseContext += "---\n\n";

  for (const query of queries) {
    try {
      const { answer, sources } = await search(query, projectName);
      baseContext += `## ${query}\n\n${answer}\n\n`;
      
      if (sources.length > 0) {
        baseContext += "**Key files:**\n";
        sources.slice(0, 3).forEach(s => {
          baseContext += `- ${s.filePath}`;
          if (s.primaryAuthor) {
            baseContext += ` (${s.primaryAuthor})`;
          }
          baseContext += `\n`;
        });
        baseContext += "\n";
      }
    } catch (e) {
      console.error(`Error generating context for: ${query}`);
    }
  }

  baseContext += "---\n\n## Project Structure\n\n";
  baseContext += await getProjectStructure(process.cwd());
  
  if (gitHistory.isRepository()) {
    const authors = await getProjectAuthors(projectName);
    if (authors.length > 0) {
      baseContext += "\n---\n\n## Code Ownership & Expertise\n\n";
      baseContext += "When making changes, consider consulting these experts:\n\n";
      
      for (const author of authors.slice(0, 5)) {
        if (author.filesOwned.length > 0) {
          baseContext += `**${author.author}** - Expert in:\n`;
          author.filesOwned.slice(0, 5).forEach(file => {
            baseContext += `- ${file}\n`;
          });
          baseContext += `\n`;
        }
      }
    }
  }

  await generateCursorRules(baseContext);
  await generateWindsurfContext(baseContext);
  await generateClineContext(baseContext);
  await generateContinueContext(baseContext);
  await generateAiderContext(baseContext);
  
  console.log("\n Context files generated for:");
  console.log("  - Cursor (.cursorrules)");
  console.log("  - Windsurf (.windsurfrules)");
  console.log("  - Cline (.clinerules)");
  console.log("  - Continue (.continuerules)");
  console.log("  - Aider (.aider.conf.yml)");
  console.log("\nüí° Your AI coding assistant will now have full codebase context!");
}

async function generateCursorRules(context: string) {
  const cursorPath = path.join(process.cwd(), ".cursorrules");
  fs.writeFileSync(cursorPath, context, "utf-8");
}

async function generateWindsurfContext(context: string) {
  const windsurfPath = path.join(process.cwd(), ".windsurfrules");
  fs.writeFileSync(windsurfPath, context, "utf-8");
}

async function generateClineContext(context: string) {
  const clinePath = path.join(process.cwd(), ".clinerules");
  fs.writeFileSync(clinePath, context, "utf-8");
}

async function generateContinueContext(context: string) {
  const continueDir = path.join(process.cwd(), ".continue");
  if (!fs.existsSync(continueDir)) {
    fs.mkdirSync(continueDir, { recursive: true });
  }
  const continuePath = path.join(continueDir, "context.md");
  fs.writeFileSync(continuePath, context, "utf-8");
}

async function generateAiderContext(context: string) {
  const aiderPath = path.join(process.cwd(), ".aider.conf.yml");
  const aiderConfig = `# Aider configuration with QuackStack context
# Project: ${path.basename(process.cwd())}

read:
  - .aider.context.md

model: gpt-4o-mini
edit-format: whole
`;
  fs.writeFileSync(aiderPath, aiderConfig, "utf-8");
  fs.writeFileSync(path.join(process.cwd(), ".aider.context.md"), context, "utf-8");
}

export async function updateGlobalContext(projectName: string) {
  const quackDir = path.join(os.homedir(), ".quackstack");
  
  if (!fs.existsSync(quackDir)) {
    fs.mkdirSync(quackDir, { recursive: true });
  }

  const contextPath = path.join(quackDir, "contexts.json");
  
  let contexts: Record<string, any> = {};
  if (fs.existsSync(contextPath)) {
    contexts = JSON.parse(fs.readFileSync(contextPath, "utf-8"));
  }

  const { answer, sources } = await search(
    "Give a brief overview of what this project does and its main components",
    projectName
  );

  contexts[projectName] = {
    path: process.cwd(),
    overview: answer,
    topFiles: sources.slice(0, 5).map(s => s.filePath),
    lastUpdated: new Date().toISOString(),
  };
  
  if (gitHistory.isRepository()) {
    const branch = gitHistory.getCurrentBranch();
    const authors = await getProjectAuthors(projectName);
    contexts[projectName].gitBranch = branch;
    contexts[projectName].contributors = authors.length;
  }

  fs.writeFileSync(contextPath, JSON.stringify(contexts, null, 2), "utf-8");
}

export function watchAndUpdateContext(projectName: string) {
  let timeout: NodeJS.Timeout;
  
  fs.watch(process.cwd(), { recursive: true }, (eventType, filename) => {
    if (!filename || filename.includes("node_modules") || filename.includes(".git")) {
      return;
    }

    clearTimeout(timeout);
    timeout = setTimeout(async () => {
      console.log("üìù Detected changes, updating context...");
      await generateContextFiles(projectName);
    }, 5000);
  });

  console.log("Watching for file changes...");
}

async function getProjectStructure(dir: string, prefix = "", maxDepth = 3, currentDepth = 0): Promise<string> {
  if (currentDepth >= maxDepth) return "";
  
  let structure = "";
  const ignoreDirs = ["node_modules", ".git", "dist", "build", ".next"];
  
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true })
      .filter(e => !ignoreDirs.includes(e.name))
      .slice(0, 20);

    entries.forEach((entry, index) => {
      const isLast = index === entries.length - 1;
      const connector = isLast ? "‚îî‚îÄ‚îÄ " : "‚îú‚îÄ‚îÄ ";
      structure += `${prefix}${connector}${entry.name}\n`;
      
      if (entry.isDirectory() && currentDepth < maxDepth - 1) {
        const newPrefix = prefix + (isLast ? "    " : "‚îÇ   ");
        structure += getProjectStructure(
          path.join(dir, entry.name), 
          newPrefix, 
          maxDepth, 
          currentDepth + 1
        );
      }
    });
  } catch (e) {
  }
  
  return structure;
}